 //------------------------------------------------------------------------------
//
// Pulse Counter.swift4a (ver 2.0)
// Swift For Arduino 4.0+
//
// Created by Swift For Arduino on 03/10/2020.
//
// NOTE: Modifications to the "Libraries:" line below will affect the build.
// Libraries:
//------------------------------------------------------------------------------

/*
    ____________________________________________________________________________

    Purpose

    Count HIGH to LOW voltage transitions on a pin and print as RPMs. As
    written, this example assumes connection to a cpu fan's tachometer output
    but pulses generated by other devices can be counted.
    ____________________________________________________________________________

    Hardware Configuration

    - D4: CPU Fan tachometer
    ____________________________________________________________________________

    Notes

    1. There are different names for the cpu fan tachometer connection. It is
    commonly referred to as TACH, FAN_TACH, SENSE, or RPM.

    2. Pin D4 and Timer0 have a special association defined interally in the
    Arduino, so the pins in this program cannot be changed.

    3. To simplify the hardware setup, the Arduino board's internal pullup
    resistors for counterPin are enabled.

    4. The messages that are printed to serial are in the Strings tab at the top
    of the window.
    ____________________________________________________________________________

    Experiments

    -
    ____________________________________________________________________________
*/

import AVR
typealias IntegerLiteralType = UInt8

//------------------------------------------------------------------------------
// Setup
//------------------------------------------------------------------------------

// Configure pins (pins are INPUT by default)
let counterPin: Pin = D4
digitalWrite(pin: counterPin, value: HIGH) // Turn on pullup resistors

// Number of pulses the fan emits for one full rotation, used in division so must not be 0
let pulsesPerRotation: UInt16 = 2

// Timer counter is a UInt8 and rolls over after 255. Reading must be fast enough to not loose counts when it rolls over. The higher the readsPerSecond, the more accurate the rpm calculation. Since integer math is used, trucation can occur and low speed pulses combined with slow reading can result in inaccurate RPM calculations.
let readsPerSecond: UInt16 = 10 // Read the counter 10 times per second

// One time calculations *** do not modify ***
let isrInterval: Milliseconds = UInt16(1000 / readsPerSecond)
let readsPerMinute: UInt16 = UInt16(60) * readsPerSecond
let pulsesToRPM: UInt16 = readsPerMinute / pulsesPerRotation


struct ISRSharedState {
    // Runtime properties that can be updated by the ISR
    // note that we handle these slightly differently
    @Volatile var shouldCalculateRPMs: Bool = false
    @Volatile var capturedPulseCount: UInt8 = 0
}

// Runtime properties
var lastPrintedPulseCount: UInt8 = 255
var periodicReadingState = ISRSharedState()

// Configure Timer0 to count voltage level changes (HIGH to LOW)
timer0SetAsCounter(edgeType: FALLING_EDGE)

// Setup periodic reading of the timer pulse counter
executeAsync(after: isrInterval, repeats: true) {

    // *** This is an interrupt service routine (ISR), code must be fast ***

    // If we are not already calculating RPMs
    if !periodicReadingState.shouldCalculateRPMs {

        // Capture current pulse count and reset counter
        periodicReadingState.capturedPulseCount = currentTimer0Value()
        timer0CounterReset()

        // Let the main loop know that it is time to calculate RPMs
        periodicReadingState.shouldCalculateRPMs = true
    }
}

// Enable serial port and let it stabilize
SetupSerial()
delay(milliseconds: 250)
print(message: "\nCPU Fan Monitor")

//------------------------------------------------------------------------------
// Main Loop
//------------------------------------------------------------------------------

while(true) {

    // If it's time to calculate AND the current pulse count is different than last printed
    if periodicReadingState.shouldCalculateRPMs,
        periodicReadingState.capturedPulseCount != lastPrintedPulseCount {

        // Calculate RPMs and print
        let rpm: UInt16 = UInt16(periodicReadingState.capturedPulseCount) &* pulsesToRPM
        print(unsignedInt: rpm, addNewline: false)
        print(message: " RPM")

        // Record that we printed this pulse count so we don't print the same value endlessly
        lastPrintedPulseCount = periodicReadingState.capturedPulseCount

        // Let ISR know we are done
        periodicReadingState.shouldCalculateRPMs = false
    }

    // We need a slight delay because our while() loop is too fast
    delay(ms: 1)
}

//------------------------------------------------------------------------------
